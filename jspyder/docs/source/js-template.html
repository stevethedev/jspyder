<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* ****************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Steven Jimenez
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to 
 * deal in the Software without restriction, including without limitation the 
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
 * sell copies of the Software, and to permit persons to whom the Software is 
 * furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * ***************************************************************************/
jspyder.extend.fn(&quot;template&quot;, function () {
    var js = this;
    if (!js) {
        console.error(&quot;Attempted to load module js-template without loading JSpyder&quot;);
        return null;
    }

    var _templates = js.createRegistry(),
        _library = js.createRegistry(),
        __master_key = ((Math.random() * 0xFFFFFFFF) | 0).toString(32);
    
<span id='jspyder-template'>    /**
</span>     * @class jspyder.template
     * @member jspyder
     * 
     * Loads the passed template into memory under the identified [name], and
     * allows the user to manipulate the template with the rest of the 
     * commands.
     * 
     * @param {String} name
     *      The name of a saved template to load from the library.  These can
     *      be stored in memory using js.template.store(name, template);
     * 
     * @param {Object} data
     *      An object defining match-variables in the key, and the values to
     *      substitute as the value.
     */
    function js_template(data) {
        if (!data || typeof data !== &quot;object&quot;) {
            data = {};
        }

        function _setData(key, d) {
            if (key === __master_key) {
                data = d;
            }
        }
        
        var compiled = &quot;&quot;;
        // obscures the interface for updating the compiled value,
        // so that it can only be done from within the javascript object.
        function _setCompiled(key, c) {
            if (key === __master_key) {
                compiled = c;
            }
        }

        var jsTmp = Object.create(js_template.fn, {
            _data: { get: function () { return data; } },
            _compiled: { get: function () { return compiled; } },
            _setData: { value: _setData },
            _setCompiled: { value: _setCompiled }
        });
        return jsTmp;
    }

    // build the expressions to search for
    var resIdentifier = &quot;\\D[a-z0-9_]*&quot;,
        resString = &quot;\&quot;(?:[^\&quot;\\\\]|\\\\.)*\&quot;&quot;,
        resCommandLiteral = &quot;\`(?:[^\`\\\\]|\\\\.)*\`&quot;,
        resNumber = &quot;\\d+(?:\\.\\d+)?&quot;,
        resVariable = &quot;\\$\\{&quot; + resIdentifier + &quot;\\}&quot;,
        resFuncName = &quot;\\@&quot; + resIdentifier,
        resFuncSep = &quot;(?:\\s*,\\s*(?!\\)))?&quot;,
        resFuncArgs = &quot;\\s*(&quot; + resCommandLiteral + &quot;|&quot; + resString + &quot;|&quot; + resNumber + &quot;|&quot; + resVariable + &quot;)&quot; + resFuncSep,
        resFunction = [resFuncName, &quot;\\((?:&quot;,
            resFuncArgs,
            &quot;)*\\)&quot;].join(''),
        resSymbol = '(' + resFunction + '|' + resVariable + ')',

        // reIdentifier = new RegExp(resIdentifier, &quot;i&quot;),
        reFuncArgs = new RegExp(resFuncArgs, &quot;i&quot;),
        reString = new RegExp(resString, &quot;i&quot;),
        reCommandLiteral = new RegExp(resCommandLiteral, &quot;i&quot;),
        reNumber = new RegExp(resNumber),
        reVariable = new RegExp(resVariable, &quot;i&quot;),
        reFuncName = new RegExp(resFuncName, &quot;i&quot;),
        reFunction = new RegExp(resFunction, &quot;i&quot;),
        reSymbol = new RegExp(resSymbol, &quot;i&quot;);

    // Retrieves a value [name] from the context [ctx] object
    function __parseVar(ctx, name) {
        var value = ctx.data[name.substring(2, name.length - 1)];
        return (typeof value === &quot;undefined&quot;
            ? name
            : value !== null
                ? value
                : &quot;&quot;);
    }

    // parses and executes a function, if it exists, using the format:
    // @[name](${var}, &quot;string&quot;, 0.5);
    function __parseFunction(tmp, ctx) {
        var name, args = [], arg, result, len, cut;

        name = tmp.match(reFuncName)[0].substring(1);
        tmp = tmp.substring(tmp.indexOf(&quot;(&quot;) + 1, tmp.lastIndexOf(&quot;)&quot;));
        while (arg = reFuncArgs.exec(tmp)) {
            cut = arg[0].length;
            len = arg.length;
            arg = arg[len - 1];
            tmp = tmp.substring(cut);

            if (!arg.search(reFunction)) {
                args.push(__parse(arg, ctx.data));
            }
            else if (!arg.search(reCommandLiteral)) {
                args.push(__parse(arg.substring(1, arg.length - 1), ctx.data));
            }
            else if (!arg.search(reString)) {
                args.push(arg.substring(1, arg.length - 1));
            }
            else if (!arg.search(reVariable)) {
                args.push(__parse(arg, ctx.data));
            }
            else if (!arg.search(reNumber)) {
                args.push(+arg);
            }
            else {
                args.push(__parse(arg, ctx.data));
            }
        }

        var fn = ctx.lib.fetch(name);
        if (fn) {
            result = fn.apply(ctx.data, args);
            if (typeof result !== &quot;undefined&quot; &amp;&amp; result !== null) {
                tmp = result;
            }
        }
        else {
            tmp = &quot;@&quot; + name + &quot;(&quot; + args.join(&quot;, &quot;) + &quot;)&quot;;
        }
        
        return tmp;
    }
    
    function __parse(tmp, data) {
        // build the context object            
        var ctx = {
            data: data,
            tmp: tmp,
            lib: _library
        };
        
        var found = null, str = &quot;&quot;, index = 0, length;
        while (found = reSymbol.exec(ctx.tmp)) {
            index = found.index;
            found = found[0];
            length = found.length;
            
            str += ctx.tmp.substring(0, index);
            ctx.tmp = ctx.tmp.substring(index + length);
            
            if (reFunction.test(found)) {
                found = __parseFunction(found, ctx);
            }
            if (reVariable.test(found)) {
                found = __parseVar(ctx, found);
            }
            
            str += found;
        }
        str += ctx.tmp; // remaining string
        
        return str;
    }

    js_template.fn = {
<span id='jspyder-template-method-compile'>        /**
</span>         * @member jspyder.template
         * 
         * Loads the passed template into memory under the identified [name], 
         * and allows the user to manipulate the template with the rest of the 
         * commands.
         * 
         * @param {String} name
         *      Identifier for a previously stored template.
         * 
         * @param {Object=} data
         *      Data object to use when running the template, where keys
         *      correspond to template values, and values correspond to the
         *      data to substitute into the template.  If omitted (or null), 
         *      then uses the object selected
         * 
         * @param {Function=} fn
         *      An optional callback function to run immediately after the
         *      template has completed parsing. Context is [data], parameter
         *      is the completed template.  
         */
        compile: function (name, data, fn) {
            var template = _templates.fetch(name);
            return this.compileExplicit(template, data, fn);
        },

<span id='jspyder-template-method-compileExplicit'>        /**
</span>         * @member jspyder.template
         * 
         * Loads the passed template into memory under the identified [name], 
         * and allows the user to manipulate the template with the rest of the 
         * commands.
         * 
         * @param {String} template
         *      A string to run as the template.
         * 
         * @param {Object=} data
         *      Data object to use when running the template, where keys
         *      correspond to template values, and values correspond to the
         *      data to substitute into the template.  If omitted (or null), 
         *      then uses the object selected
         * 
         * @param {Function=} fn
         *      An optional callback function to run immediately after the
         *      template has completed parsing. Context is [data], parameter
         *      is the completed template.  
         */
        compileExplicit: function (template, data, fn) {
            if (typeof data === &quot;function&quot; &amp;&amp; !fn) {
                fn = data;
                data = null;
            }
            if (typeof template === &quot;undefined&quot;) {
                template = &quot;&quot;;
            }
            // template = template.replace(/[\n\r\f\s]+/gi, &quot; &quot;);
            var o = Object.create(this._data);
            js.alg.each(data || {}, function (v, k, _, o) {
                o[k] = v;
            }, o);
            var tmp = __parse(template, o);
            
            this._setCompiled(__master_key, tmp);
            
            typeof fn === &quot;function&quot; &amp;&amp; fn.apply(this, [tmp]);
            return this;
        },
        
<span id='jspyder-template-method-output'>        /**
</span>         * @member jspyder.template
         * 
         * @return The last compiled template, as a string.
         */
        output: function () { return this._compiled; },
        
<span id='jspyder-template-method-outputDom'>        /**
</span>         * @member jspyder.template
         * 
         * @param {Function} [fn]
         *      If provided, then this function will be executed upon DOM node
         *      creation.
         * 
         * @return The last compiled template, as a DOM element.
         */
        outputDom: function (fn) { return js.dom(this._compiled, fn); },
        
<span id='jspyder-template-method-storeTemplate'>        /**
</span>         * @member jspyder.template
         * 
         * Loads the passed template into memory under the identified [name], 
         * and allows the user to manipulate the template with the rest of the 
         * commands.
         * 
         * @param {String} name
         *      Identifier to use when referring to this template.
         * 
         * @param {Mixed=} template
         *      Template string to load into the template library, or [null] 
         *      to remove the template from storage.
         */
        storeTemplate: function (name, template) {
            template = js.alg.string(template, &quot;&quot;);
            template = template.replace(/\&lt;\!\-\-[^\&lt;]+\-\-\&gt;/g, &quot;&quot;).replace(/\&lt;([^\s\&gt;]+)([^\&gt;]+)\/\&gt;/i, &quot;&lt;$1 $2&gt;&lt;/$1&gt;&quot;);
            _templates.stash(name, template);
            return this;
        },
        
<span id='jspyder-template-method-storeTemplateXml'>        /**
</span>         * @member jspyder.template
         * 
         * Loads templates from the specified XML file, using the following 
         * format:
         * 
         * ```#!xml
         * &lt;templates&gt;
         *   &lt;template name=&quot;template-name&quot;&gt;
         *     Template Contents
         *   &lt;/template&gt;
         * &lt;/templates&gt;
         * ```
         * 
         * This function requires jspyder.ajax to function
         * 
         * @param {String} filename
         *      The URL to the template file, to be called via AJAX
         * 
         * @param {Function} [fn]
         *      The callback function to execute after the template is loaded.
         */
        storeTemplateXml: function (filename, fn) {
            var errorMsg = &quot;Attempted to call jspyder.template.storeTemplateXml() without loading jspyder.ajax module!&quot;;
            filename = js.alg.string(filename);
                
            if (js.ajax) {
                var data = {
                    // self: this,
                    xmls: new XMLSerializer(),
                    fn: fn
                };
                    
                js.ajax(filename)
                    .get(js_template.fn._storeTemplateXml_ajax, data);
            }
            else {
                js.log.error(errorMsg);
            }
            return this;
        },
        
<span id='jspyder-template-method-_storeTemplateXml_ajax'>        /** @private */
</span>        _storeTemplateXml_ajax: function (xhttp, data) {
            if(js.env.browser.name === &quot;IE&quot; &amp;&amp; js.env.browser.version &lt;= 9) {
                js_template.fn._storeTemplateXml_ajax = function(xhttp, data) {
                    var xml = js_template.fn._storeTemplateXml_parseXml(xhttp.responseText),
                        $xml = js.dom(xml.firstChild);
                        
                    $xml.children(js_template.fn._storeTemplateXml_children, data);
                    js.alg.run(data.fn);
                }
            }
            else {
                js_template.fn._storeTemplateXml_ajax = function(xhttp, data) {
                    var $xml = js.dom(xhttp.responseXML.firstChild);
                        
                    $xml.children(js_template.fn._storeTemplateXml_children, data);
                    js.alg.run(data.fn);
                }
            }
            
            return js_template.fn._storeTemplateXml_ajax.apply(this, arguments);
        },
        _storeTemplateXml_parseXml: function parseXml(xmlText){
            try{
                var text = xmlText,
                    doc = null;
                    
                if (typeof DOMParser != &quot;undefined&quot;) { 
                    var parser=new DOMParser();
                    doc=parser.parseFromString(text,&quot;text/xml&quot;);
                    return doc; 
                }
                else if (typeof ActiveXObject != &quot;undefined&quot;) { 
                    // Internet Explorer. 
                    doc = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);  // Create an empty document 
                    doc.loadXML(text);            // Parse text into it 
                    return doc;                   // Return it 
                } 
                else { 
                    var url = &quot;data:text/xml;charset=utf-8,&quot; + encodeURIComponent(text); 
                    var request = new XMLHttpRequest(); 
                    request.open(&quot;GET&quot;, url, false); 
                    request.send(null); 
                    return request.responseXML; 
                }
            }
            catch(err){
                js.log.error(&quot;There was a problem parsing the xml: &quot; + err.message);
            }
            return &quot;&lt;templates&gt;&lt;/templates&gt;&quot;;
        },
        
<span id='jspyder-template-method-_storeTemplateXml_children'>        /** @private */
</span>        _storeTemplateXml_children: function (child, data) {
            js_template.fn.storeTemplate(
                child.getAttribute(&quot;name&quot;),
                data.xmls.serializeToString(child)
                    .replace(/\&lt;[\/]?template[^\&gt;]*\&gt;/g, &quot;&quot;));
            return;
        },
        
<span id='jspyder-template-method-getTemplate'>        /**
</span>         * @member jspyder.template
         * 
         * Pulls the selected template, and runs [fn] with the template as the
         * context. 
         * 
         * @param {String} name
         *      Identifier to use when referring to this template.
         * 
         * @param {Function} fn
         *      Callback to run with the template as the context.
         */
        getTemplate: function (name, fn) {
            _templates.fetch(name, fn);
            return this;
        },
        
<span id='jspyder-template-method-register'>        /**
</span>         * @member jspyder.template
         * 
         * Registers a function with the templates library, to make it
         * available within the templates.
         * 
         * @param {String} name
         *      Identifier to within the templates.  Accessible by name()
         * 
         * @param {Function} fn
         *      Function to call when invoked by name() in the templates.
         */
        register: function (name, fn) {
            if (typeof fn === &quot;function&quot;) {
                _library.stash(name, fn);
            }
            return this;
        },
        
<span id='jspyder-template-method-registerSet'>        /**
</span>         * @member jspyder.template
         * 
         * Registers a set of functions through js.template.register()
         * 
         * @param {Object} o
         *      Registers o's keys as function names, and o's values as
         *      the functions to execute when @key() is invoked within a
         *      template.
         */
        registerSet: function (o) {
            var self = this;
            js.alg.each(o, function (v, k) { self.register(k, v); });
            return this;
        }
    };

    js_template[&quot;storeTemplate&quot;]    = js_template[&quot;fn&quot;][&quot;storeTempate&quot;];
    js_template[&quot;storeTemplateXml&quot;] = js_template[&quot;fn&quot;][&quot;storeTemplateXml&quot;];
    js_template[&quot;getTemplate&quot;]      = js_template[&quot;fn&quot;][&quot;getTemplate&quot;];
    js_template[&quot;compile&quot;]          = js_template[&quot;fn&quot;][&quot;compile&quot;];
    js_template[&quot;compileExplicit&quot;]  = js_template[&quot;fn&quot;][&quot;compileExplicit&quot;];
    js_template[&quot;register&quot;]         = js_template[&quot;fn&quot;][&quot;register&quot;];
    js_template[&quot;registerSet&quot;]      = js_template[&quot;fn&quot;][&quot;registerSet&quot;];
    
<span id='jspyder-template-property-commands'>    /**
</span>     * @property commands
     * @member jspyder.template
     * 
     * JS-Template Commands, which are available upon template-compilation
     */
    js_template.registerSet({

<span id='jspyder-template-commands-method-each'>        /**
</span>         * @method each
         * @member jspyder.template.commands
         * 
         * &amp;#64;each(frm, push, template)&lt;br /&gt;
         * Iterates through each element in the variable referenced by
         * [frm].  It then compiles the template [template], and pushes
         * the data into the declared variable [push].
         */
        &quot;each&quot;: function (frm, push, template) {
            var data = this[frm] || {},
                pushObj = Object.create(this),
                ret = &quot;&quot;,
                $t = js_template(data);
                
            js.alg.each(data, function (v, k, data, ctx) {
                pushObj[push] = v;
                ret += $t.compileExplicit(template, pushObj).output();
            }, this);
            
            return ret;
        },
        
<span id='jspyder-template-commands-method-insert_template'>        /**
</span>         * @method insert_template
         * @member jspyder.template.commands
         * 
         * &amp;#64;insert_template(name, [arg1, [arg2, [...]]])&lt;br /&gt;
         * Wrapper for jspyder.template.compile(templateId), where
         * templateId = [name].
         */
        &quot;insert_template&quot;: function (name) {
            var tmp = &quot;&quot;;
            var o = Object.create(this);
            
            for(var i = 1; i &lt; arguments.length; ++i) {
                o[arguments[i]] = o[arguments[++i]];
            }
            
            o.arguments = js.alg.sliceArray(arguments, 1);
            
            js_template(o).compile(name, function (v) { tmp = v; });
            return tmp; 
        },

<span id='jspyder-template-commands-method-arguments'>        /**
</span>         * @method arguments
         * @member jspyder.template.commands
         * 
         * &amp;#64;arguments(n)&lt;br /&gt;
         * Grabs the [n]th argument from the list from the calling
         * function (e.g. &amp;#64;insert_template).  These values correspond
         * to the values passed in, following the template name. 
         */
        &quot;arguments&quot;: function (n) {
            n = js.alg.number(n);
            return (this.arguments ? this.arguments[n] || &quot;&quot; : &quot;&quot;);
        },

<span id='jspyder-template-commands-method-iif'>        /**
</span>         * @method iif
         * @member jspyder.template.commands
         * 
         * &amp;#64;iif(test, pass, fail)&lt;br /&gt;
         * branching logic.  If [test] is true, then inserts [pass],
         * else inserts [fail].
         * TODO: Make this native support, so that it won't have
         * to parse both paths ad infinitum before executing the
         * function.
         */
        &quot;iif&quot;: function (test, pass, fail) {
            var $t = js_template(this);
            
            if (typeof test === &quot;string&quot;) {
                test = $t.compileExplicit(test).output();
            }
            
            if (!!test) {
                return $t.compileExplicit(pass).output();
            }
            else {
                return $t.compileExplicit(fail).output();
            }
        },

<span id='jspyder-template-commands-method-map_size'>        /**
</span>         * @method map_size
         * @member jspyder.template.commands
         * 
         * &amp;#64;map_size(arrayName)&lt;br /&gt;
         * Gets the length of the variable name identified by [arrayName]
         */
        &quot;map_size&quot;: function (arrayName) {
            var data = this[arrayName];
            
            return (data &amp;&amp; data.length
                ? data.length
                : typeof data === &quot;undefined&quot;
                    ? 0
                    : 1); 
        },

<span id='jspyder-template-commands-method-add'>        /**
</span>         * @method add
         * @member jspyder.template.commands
         * 
         * &amp;#64;add(n, a, [b, [c, [...]]])&lt;br /&gt;
         * Calculates the sum of the numbers passed
         */
        &quot;add&quot;: function (n, a) {
            var num = js.alg.number;
            var sum = num(n);
            for(var i = 1; i &lt; arguments.length; i++) {
                sum += num(a);
            }
            return n;
        },

<span id='jspyder-template-commands-method-var'>        /**
</span>         * @method var
         * @member jspyder.template.commands
         * 
         * &amp;#64;var(name, value)&lt;br /&gt;
         * Defines a scoped variable within the template
         */
        &quot;var&quot;: function (name, value) {
            if (arguments.length === 1) {
                return this[name] || &quot;&quot;;
            }
            this[name] = value;
            return &quot;&quot;;
        },

<span id='jspyder-template-commands-method-map'>        /**
</span>         * @method map
         * @member jspyder.template.commands
         * 
         * &amp;#64;map(name, [key1, value1, [key2, value2, [...]]])&lt;br /&gt;
         * Defines a map under variable [name], using key-value pairs
         * as defined.
         */
        &quot;map&quot;: function (name) {
            var map = {};
            
            for (var i = 1; i &lt; arguments.length; i += 2) {
                map[arguments[i]] = arguments[i + 1];
            }
            
            this[name] = map;
            return &quot;&quot;;
        },

<span id='jspyder-template-commands-method-map_item'>        /**
</span>         * @method map_item
         * @member jspyder.template.commands
         * 
         * &amp;#64;map_item(map, id)&lt;br /&gt;
         * Gets the value from the map identified by [map], using
         * [id] as a key
         */
        &quot;map_item&quot;: function (map, id) {
            map = this[map];
            return (map ? map[id] : id);
        },

<span id='jspyder-template-commands-method-js_registry'>        /**
</span>         * @method js_registry
         * @member jspyder.template.commands
         * 
         * &amp;#64;js_registry(key)&lt;br /&gt;
         * Retrieves [key] from the JSpyder registry
         */
        &quot;js_registry&quot;: function (key) {
            var data = js.registry.fetch(key);
            return (data === null || typeof data === &quot;undefined&quot;
                ? &quot;&quot; : data);
        },

<span id='jspyder-template-commands-method-js_log'>        /**
</span>         * @method js_log
         * @member jspyder.template.commands
         * 
         * &amp;#64;js_log(data)&lt;br /&gt;
         * Useful as a debugging tool, this outputs data to the console when
         * a template is compiled.
         */
        &quot;js_log&quot;: function (data) {
            console.log(data);
        },

<span id='jspyder-template-commands-method-concat'>        /**
</span>         * @method concat
         * @member jspyder.template.commands
         * 
         * &amp;#64;concat(str, [str2, [str3, [...]]])&lt;br /&gt;
         * Merges all of the strings provided into a single string
         */
        &quot;concat&quot;: function(str) {
            for(var i = 1; i &lt; arguments.length; i++) {
                str += arguments[i];
            }
            return str;
        },

<span id='jspyder-template-commands-method-html'>        /**
</span>         * @method html
         * @member jspyder.template.commands
         * 
         * &amp;#64;html(str)&lt;br /&gt;
         * Retrieves the HTML codes from [str] to convert it into an escaped-string
         */
        &quot;html&quot;: function(str) {
            js.dom(&quot;&lt;div&gt;&quot; + str + &quot;&lt;/div&gt;&quot;).getText(function(v) { str = v; });
            return str;
        },

<span id='jspyder-template-commands-method-escape'>        /**
</span>         * @method escape
         * @member jspyder.template.commands
         * 
         * &amp;#64;escape(n, a, [b, [c, [...]]])&lt;br /&gt;
         * Converts a string into HTML codes
         */
        &quot;escape&quot;: function (str) {
            var ret = [];
            str = str.split(/\r?\n/);
            js.alg.arrEach(str, function (str) {
                var t = [];
                js.alg.iterate(0, str.length, function (i) {
                    t.push(&quot;&amp;#&quot;, str.charCodeAt(i), &quot;;&quot;);
                });
                ret.push(t.join(''));
            });
            return ret.join('&lt;br /&gt;');
        },

<span id='jspyder-template-commands-method-tag'>        /**
</span>         * @method tag
         * @member jspyder.template.commands
         * 
         * &amp;#64;tag(tag, props)&lt;br /&gt;
         * Creates an HTML [tag], using [props] as the attributes.  This is
         * useful within XML templates, which often mis-interpret the XML
         * as HTML if a tag has no content.
         */
        &quot;tag&quot;: function (tag, props) {
            tag = js.alg.string(tag, &quot;br&quot;);
            props = js.alg.string(props, &quot;&quot;);
            var voidElement = /^(area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)\b/i.test(tag);
            return &quot;&lt;&quot; + tag + &quot; &quot; + props + (voidElement ? &quot; /&quot; : &quot;&gt;&lt;/&quot; + tag ) + &quot;&gt;&quot;;
        }
    });
    
    js.template = js_template;
    return js_template;
});</pre>
</body>
</html>
