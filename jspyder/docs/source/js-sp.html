<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* ****************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Steven Jimenez
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to 
 * deal in the Software without restriction, including without limitation the 
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
 * sell copies of the Software, and to permit persons to whom the Software is 
 * furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * ***************************************************************************/
 
js.extend.fn(&quot;sp&quot;, function () {
<span id='global-property-js'>    /** @ignore */
</span>    var js = window.jspyder;
    
<span id='jspyder-sp'>    /**
</span>     * @class jspyder.sp
     * @member jspyder
     * 
     * # Managed Objects:
     * ## JSpyder SharePoint List Reference (jspyder.sp.list)
     * ## JSpyder SharePoint Query Reference (jspyder.sp.query)
     */
    function sp() { };
    
<span id='jspyder-sp-list'>    /**
</span>     * @class jspyder.sp.list
     * @extends jspyder.sp
     * 
     * @param {Object} config
     *      A configuration object for the initial setup of the SP list 
     *      reference. Though a valid object will return if this parameter
     *      is not included, it will not point anywhere and trying to use it
     *      may throw errors.
     * 
     * @param {String} [config.url]
     *      The site collection the sharepoint list belongs to.
     * 
     * @param {String} [config.name]
     *      The name of the sharepoint list to connect to.
     * 
     * @param {Function} [config.success]
     *      The default function to fire when a [sp.list.pull]{#sp.list.pull}
     *      command completes successfully.
     * 
     * @param {Function} [config.failure]
     *      The default function to fire when a [sp.list.pull]{#sp.list.pull}
     *      command fails.
     * 
     * @param {String} [config.caml]
     *      The CAML configuration to use when initializing the sharepoint
     *      list reference.
     * 
     * @return {Object} 
     *      A JSpyder SharePoint List Reference Object ([sp.list]{#sp.list})
     */
    sp.list =  function spList(config, fn) {
         
        if (!window.SP) {
            js.log.warn(
                &quot;Ensure that MicrosoftAjax.js, sp.runtime.js, and sp.js &quot; +
                &quot;have been loaded before using JSpyder SharePoint Interface&quot;);
        }

        var list = Object.create(sp.list.fn);

        if (config) {
            if (config.url) {
                list._url = config.url;
            }
            if (config.name) {
                list._name = config.name;
            }
            if (typeof config.success === &quot;function&quot;) {
                list._success = config.success;
            }
            if (typeof config.failure === &quot;function&quot;) {
                list._failure = config.failure;
            }
            if (config.caml) {
                list._caml = config.caml;
            }
        }
        
        list._columns = {};
        list._rows = [];
        list._dirtyRows = [];
        
        js.alg.use(list, fn);

        return list;
    }

    var __rowLimit = 10000;
    var __caml = &quot;&lt;View&gt;&lt;Query&gt;&lt;Where&gt;&lt;Geq&gt;&lt;FieldRef Name=&#39;ID&#39; /&gt;&quot;
        + &quot;&lt;Value Type=&#39;Number&#39;&gt;1&lt;/Value&gt;&lt;/Geq&gt;&lt;/Where&gt;&lt;/Query&gt;&quot;
        + &quot;&lt;RowLimit&gt;&quot; + __rowLimit + &quot;&lt;/RowLimit&gt;&lt;/View&gt;&quot;

    sp.list.fn = {
        // private:
        _url: &quot;&quot;,
        _name: &quot;&quot;,
        _success: function () { },
        _failure: function () { },
        _caml: __caml,
        _columns: {},
        _rows: [],
        _dirtyRows: [],
        get length() {
            return this._rows.length;
        },
        
<span id='jspyder-sp-list-method-addColumn'>        /**
</span>         * Adds a single column to the SP List proxy
         * 
         * @param {String} name
         *      The way this column will be referred to in javascript
         * 
         * @param {Object} data
         *      The template overrides for the sharepoint list column 
         *      reference. The fields included will overwrite all default
         *      values except &quot;name&quot; or &quot;list&quot;, as they are read-only 
         *      attributes pointing back to the defined name and list object, 
         *      respectively.   
         * 
         *          @param {String} [data.internal] 
         *              Name of the sharepoint field, to SharePoint.  If the
         *              list reference is expected to fill a value with data
         *              from the server, then this field must accurately reflect
         *              the actual name.
         * 
         *          @param {String} [data.text]     
         *              Name of the sharepoint field, to the user.  This will be
         *              the human-readable name, which can include spaces and
         *              punctuation.
         * 
         *          @param {String} [data.type]     
         *              SharePoint field data type, in all lower-case string.
         * 
         *          @param {String} [data.default]  
         *              Default value, if none can be found on a query.
         * 
         *          @param {Function} [data.macro]  
         *              Defines a custom value lookup.  This will override (and
         *              not consider) any values found if a data.internal parameter
         *              is provided.
         */
        addColumn: function(name, data) {
            var column = Object.create(sp.column.fn, {
                list: { value: this },
                name: { value: name }
            });
            
            js.alg.mergeObj(column, data);
            if(typeof data[&quot;default&quot;] === &quot;undefined&quot;) {
                if(column.type === &quot;number&quot;) {
                    column[&quot;default&quot;] = 0;
                }
            }
            
            this._columns[name] = column;
            
            return this;
        },
<span id='jspyder-sp-list-method-addColumns'>        /**
</span>         * Adds a group of columns to the SP List proxy, via this.addColumn,
         * where keys correspond to the [name] parameter, and values correspond
         * to the [data] parameter.
         * 
         * @param {Object} dataObj
         */
        addColumns: function(dataObj) {
            js.alg.each(dataObj, function(data, name, dataObj, list) {
                list.addColumn(name, data);
            }, this);
            return this;
        },
        
<span id='jspyder-sp-list-method-getColumn'>        /**
</span>         * Gets the column template by name, as identified in js.sp.list.addColumn
         * 
         * @param {String} name
         *      The name of the field to retrieve the template for. Note that
         *      any changes to the template will change the template for all
         *      of the derived values within the table.
         */
        getColumn: function(name) {
            return (this._columns[name]
                ? this._columns[name] 
                : Object.create(sp.column.fn, {
                    list: { value: this },
                    name: { value: name }}));
        },
        
<span id='jspyder-sp-list-method-getRow'>        /**
</span>         * Gets the row number from the cache of stored values.  Note that this
         * number does not necessarily correspond to the row ID within 
         * SharePoint.
         * 
         * @param {Number} n
         *      The row number to retrieve from the cache.
         */
        getRow: function(n) {
            return this._rows[js.alg.number(n, 0)] || null;
        },
        
<span id='jspyder-sp-list-method-getRowById'>        /**
</span>         * 
         */
        getRowById: function(id) {
            var found = null,
                row = null,
                i = 0;
        
            while(row = this.getRow(i++)) {
                if(row[&quot;ID&quot;][&quot;value&quot;] === id) {
                    found = row;
                    break;
                }
                
            }
            
            return found;
        },
        
<span id='jspyder-sp-list-method-eachDirtyRow'>        /**
</span>         * Gets the dirty rows
         */
        eachDirtyRow: function(fn, data) {
            var dirty = this._dirtyRows;
                
            if(typeof fn === &quot;function&quot;) {
                js.alg.each(dirty, fn, data);
            }
            
            return this;
        },
        
        _createListItem: function() {
            
        },
        
<span id='jspyder-sp-list-method-getRowCount'>        /**
</span>         * Retrieves the number of rows within the cache.
         * 
         * @return {Number}
         */
        getRowCount: function(n) {
            return this._rows.length;
        },
        
<span id='jspyder-sp-list-method-pull'>        /**
</span>         * Executes an asynchronous read-query from the server to pull in 
         * fresh data. It is important to note, when using this function, that
         * any subsequent or chained functions will likely execute before this
         * query has returned.
         * 
         * @param {Function} [success]
         *      The function to execute after data has been loaded into the
         *      jsSPList object, iif the query was successful.  This function
         *      will be executed instead of the success function identified
         *      in the constructor.
         * 
         * @param {Function} [failure]
         *      The function to execute if the data query failed, accepting
         *      [sender, args] as the parameters.  This function will be 
         *      executed instead of the failure function identified in the
         *      constructor.
         * 
         * @async
         */
        pull: function (success, failure) {
            var ctx = new window.SP.ClientContext(this._url),
                list = ctx.get_web().get_lists().getByTitle(this._name),
                caml = new window.SP.CamlQuery(),
                successFn = (typeof success === &quot;function&quot;
                    ? success
                    : this._success),
                failureFn = (typeof failure === &quot;function&quot;
                    ? failure
                    : this._failure);

            caml.set_viewXml(this.caml);
            var listItems = list.getItems(caml);

            ctx.load(listItems);
            
            ctx.executeQueryAsync(
                js.alg.bindFn(this, __successParse, [listItems, successFn]),
                js.alg.bindFn(this, __failureParse, [listItems, failureFn]));
            return this;
        },
        
<span id='jspyder-sp-list-method-query'>        /**
</span>         * Creates a new query object. This function is synchronous, and 
         * executes data currently residing in the cache.
         * 
         * @param {Array} criteria
         *      A list of criteria to run against the list reference&#39;s cache.
         *      Expected as an array of query objects.  See jspyder.sp.query.filter
         * 
         * @return {Object}
         *      [Query Reference]{#sp.query}
         */
        query: function (criteria) {
            var query = sp.query(this).reset();
            return (criteria instanceof Array
                ? query.filters(criteria)
                : query.filter(criteria));
        },

<span id='jspyder-sp-list-method-clearData'>        /**
</span>         * Clears all cached data within the list reference.  This is function
         * is automatically called when pulling data from the SharePoint List,
         * and should not be necessary for most implementations.
         */
        clearData: function () {
            this._rows = [];
            while(this._dirtyRows.pop()) {
                // nothing
            }
            js.alg.each(this._columns, function (colData) {
                colData.rowIDs = {}; //&lt; stores RowID:[Value,Value,Value]
                colData.values = {}; //&lt; stores Value:[RowID,RowID,RowID] 
            });
            return this;
        },
        
<span id='jspyder-sp-list-method-push'>        /**
</span>         * Pushes changed data to the server.
         * 
         * !TODO: Implement the logic for this:
         *  1: Loop through all rows
         *  2: Loop through all columns
         *  3: Find relevant changes
         *  4: Stash them in ClientContext
         *  5: Push
         * 
         * Alternatively, I could cache the changed values when I mark them as
         * &quot;dirty&quot;.
         *  
         * @async
         */
        push: function(success, failure) {
            var ctx = new window.SP.ClientContext(this._url),
                list = ctx.get_web().get_lists().getByTitle(this._name),
                data = {
                    clientContext: ctx,
                    items: [],
                    list: list,
                    self: this
                };

            this.eachDirtyRow(this._pushLoopDirtyRows, data);

            ctx.executeQueryAsync(
                js.alg.bindFn(this, __successPush, [data.items, success]),
                js.alg.bindFn(this, __failurePush, [data.items, failure]));
                
            return this;
        },
        _pushLoopDirtyRows: function(row, i, rows, data) {
            var rowID = row.ID.value,
                itemInfo = null,
                listItem = null;
            
            if(row.ID.value &lt; 0) {
                itemInfo = new SP.ListItemCreationInformation();
                listItem = data.list.addItem(itemInfo);
                data.newrow = true;
            }
            else {
                listItem = data.list.getItemById(rowID);
                data.newrow = false;
            }
            
            // set all list item values
            data.listItem = listItem;
            js.alg.each(row, data.self._pushLoopDirtyRowColumns, data);
            // ----
            
            data.items.push(listItem);
            
            // cache data for update
            listItem.update();
            data.clientContext.load(listItem);
        },
        _pushLoopDirtyRowColumns: function(coldata, colname, columns, data) {
            if(coldata.internal &amp;&amp; coldata.dirty &amp;&amp; (coldata.internal !== &quot;ID&quot;)) {
                data.listItem.set_item(coldata.internal, coldata.value);
            }
            return;
        },
        
        updateRow: function(id, values) {
            var row = this.getRowById(id),
                data = js.alg.mergeObj({}, values);
                
                if(row) {
                    js.alg.each(row, this._updateRowEach, data);
                }
            
            return this;
        },
        _updateRowEach: function (colData, colName, row, data) {
            var row = data.row,
                value = data[colData.name],
                valDefined = (typeof value !== &quot;undefined&quot;),
                valDifferent = (value !== colData.value);  
            
            if (valDefined &amp;&amp; valDifferent) {
                colData.value = value;
            }
            
            return;
        },
<span id='jspyder-sp-list-method-createRow'>        /**
</span>         * @method
         */
        createRow: function(values) {
            var columns = this._columns,
                data = {
                    row: {},
                    rowID: -1,
                    values: js.alg.mergeObj({}, values)
                };
            
            js.alg.each(columns, this._createRowEach, data);
            data.row.ID.value = data.rowID;
            this._dirtyRows.push(data.row);
            
            return this;
        },
        _createRowEach: function (colData, colName, column, data) {
            var row = data.row,
                value = data.values[colData.name],
                cell = Object.create(colData, {
                    rowID: { value: data.rowID },
                    dirty: { get: function() { return colValue !== null; } },
                    value: {
                        get: function () {
                            return (typeof this.macro === &quot;function&quot;
                                ? this.macro(row)
                                : colValue);
                        },
                        set: function (v) {
                            if (colData.internal) {
                                colValue = v;
                            }
                        }
                    }
                }),
                colValue = (typeof value !== &quot;undefined&quot; ? value : colData.default || null);
            
            row[colData.name] = cell;
        },
        
<span id='jspyder-sp-list-method-getPermissions'>        /**
</span>         * @method
         * 
         * Retrieves the permission levels for the current user in the
         * associated list.
         * 
         * @param {Function} success
         *      The function to execute if the permissions were successfully retrieved.
         * 
         * @param {Function} failure
         *      The function to execute if the permissions failed to retrieve.
         * 
         * @async
         */
        getPermissions: function (success, failure) {
            var ctx = new window.SP.ClientContext(this._url),
                web = ctx.get_web(),
                data = {
                    currentUser: web.get_currentUser(),
                    web: web
                };
                
            ctx.load(data.currentUser);
            ctx.load(web, &quot;EffectiveBasePermissions&quot;);
            ctx.executeQueryAsync(
                js.alg.bindFn(this, this._getPermissionsSuccess, [data, success]),
                js.alg.bindFn(this, this._getPermissionsSuccess, [null, failure]));
                
            return this;
        },
        _getPermissionsSuccess: function (data, callback, sender, args) {
            var permissions = this._permissions = {};
            
            if (data) {
                var perm = data.web.get_effectiveBasePermissions();

                js.alg.each(new window.SP.PermissionKind(), function (pValue, pName) {
                    permissions[pName] = js.alg.bool(perm.has(pValue));
                });
                js.alg.use(this, callback, [this._permissions]);
                return;
            }
            
            js.alg.use(this, callback, [sender, args]);
            return;
        }
    };

<span id='jspyder-sp-list-method-__successPush'>    /**
</span>     * @private
     * Called after a successful data push
     */
    function __successPush(listItems, successFn, sender, args) {
        // console.log(&quot;Successfully pushed &quot; + listItems.length + &quot; items!&quot;);
        js.alg.use(this, successFn, [sender, args, listItems]);
        while(this._dirtyRows.pop()) { /* nothing */ }
        this.pull();
        return;
    }
    
<span id='jspyder-sp-list-method-__failurePush'>    /**
</span>     * @private
     * Called after an unsuccessful data push
     */
    function __failurePush(listItems, failureFn, sender, args) {
        // console.log(&quot;Failed to push &quot; + listItems.length + &quot; items!&quot;);
        js.alg.use(this, failureFn, [sender, args, listItems]);
        return;
    }

<span id='jspyder-sp-list-method-__successParse'>    /** ***********************************************************************
</span>     * @private
     * Called after a successful query; loads data into the list reference.
     * 
     * @param {Object} listItems
     *      SharePoint List Items collectionbeing processed
     * 
     * @param {Function} successFn
     *      Function to run after SP List has completed
     * 
     * @param {Object} sender
     *      Pushed in by SharePoint
     * 
     * @param {Object} args
     *      Pushed in by SharePoint  
     * ***********************************************************************/
    function __successParse(listItems, successFn, sender, args) {
        var itemEnumerator = listItems.getEnumerator(),
            jsEach = js.alg.each,
            columns = this._columns,
            currentItem = null,
            data = null,
            row = null;

        this.clearData();
        
        // move through each item
        while (itemEnumerator.moveNext()) {
            row = {};
            currentItem = itemEnumerator.get_current();
            // grab each of our stored items
            data = { item: currentItem, id: currentItem.get_id(), _row: row };
            jsEach(columns, __pushRow, data);
            this._rows.push(row);
        }

        successFn(sender, args);
    }
    
<span id='jspyder-sp-list-method-__pushRow'>    /** ***********************************************************************
</span>     * @private
     * Called in a loop to push data into the SP List Reference. This function 
     * is defined outside of the loop for efficiency.
     * 
     * @param {Object} colData
     *      Individual column template (based on sp.column.fn)
     * 
     * @param {String} colName
     *      Column&#39;s internal reference ID, defined in constructor
     * 
     * @param {Object} columns
     *      Collection of js column references
     * 
     * @param {Object} data
     *      Collection of relevant loop data, pushed in my js.alg.each.
     *      Includes data.item (sharepoint row reference), data.id (value of
     *      associated row ID in sharepoint), and data._row (reference to
     *      list reference&#39;s row getting pushed into the stack).  
     * ***********************************************************************/
    function __pushRow(colData, colName, columns, data) {
        var rowID = data.id,
            row = data._row,
            dirty = false,
            cell = Object.create(colData, {
                rowID: { value: rowID },
                dirty: { get: function() { return dirty; } },
                value: {
                    get: function () {
                        return (typeof this.macro === &quot;function&quot;
                            ? this.macro(row)
                            : colValue);
                    },
                    set: function (v) {
                        if (colData.internal) {
                            colValue = v;
                            dirty = true;
                            if(colData.list._dirtyRows.indexOf(row) &lt; 0) {
                                colData.list._dirtyRows.push(row);
                            }
                        }
                    }
                }
            }),
            colValue = colData.default;

        if (colData.internal) {
            try {
                colValue = data.item.get_item(colData.internal);
            
                // eventually, this will need to change to support multi-value fields.
                colData.rowIDs[rowID] = colValue;

                if (!colData.values[colValue]) {
                    colData.values[colValue] = [];
                }
                colData.values[colValue].push(rowID);
            }
            catch(e) {
                js.log.warn(&quot;Could not load data from column name &quot; + colData.internal);
            }
        }
        
        colValue = __parseValueType(colData, colValue);
        
        row[colData.name] = cell;

        return;
    }
    
<span id='jspyder-sp-list-method-__parseValueType'>    /**
</span>     * Parses the colData variable for the value type, and then ensures that
     * value meets those requirements.  If it does not meet the requirements,
     * then it is either converted to the correct data type, or it is set to
     * the default value.
     * 
     * @param {Object} colData
     *      Column template (based on sp.column.fn)
     * 
     * @param {Mixed} value
     *      The value to test and/or convert.
     */
    function __parseValueType(colData, value) {
        switch(colData.type) {
            case &quot;bitflag&quot;:
            case &quot;number&quot; :
                value = js.alg.number(value);
                break;
            case &quot;string&quot; :
            case &quot;text&quot; :
                value = js.alg.string(value);
                break;
            default:
                break;
        }
        return value;
    }

<span id='jspyder-sp-list-method-__failureParse'>    /** ***********************************************************************
</span>     * @private
     * Called after a failed query; loads data into the list reference.
     * 
     * @param {Object} listItems
     *      SharePoint List Items collectionbeing processed
     * 
     * @param {Function} failureFn
     *      Function to run after SP List has completed
     * 
     * @param {Object} sender
     *      Pushed in by SharePoint
     * 
     * @param {Object} args
     *      Pushed in by SharePoint  
     * ***********************************************************************/
    function __failureParse(listItems, failureFn, sender, args) {
        failureFn(sender, args);
    }


<span id='jspyder-sp-query'>    /** ***********************************************************************
</span>     * @class jspyder.sp.query
     * @extends jspyder.sp
     * 
     * This class should not generally be directly created in scripts. Instead,
     * it should be either created by a call to jspyder.sp.list.query() or a 
     * call to jspyder.sp.query.clone in order to ensure that it was properly 
     * configured at creation and before use.
     * ***********************************************************************/
    sp.query = function(list) {
        return Object.create(sp.query.fn, { _list: { value: list } });
    };
    
    sp.query.fn = {
<span id='jspyder-sp-query-property-_list'>        /** @private Overwritten at creation. */
</span>        _list: null,
<span id='jspyder-sp-query-property-_rows'>        /** @private Overwritten at creation and reset. */
</span>        _rows: null,
        
        get length() {
            return this._rows.length;
        },
        
        row: function(n) {
            return this._rows[js.alg.number(n)];
        },
        
<span id='jspyder-sp-query-method-reset'>        /** *******************************************************************
</span>         * Resets the query object to include all of the available rows in the
         * associated list&#39;s cache.
         * *******************************************************************/
        reset: function() {
            this._rows = this._list._rows.slice(0);
            return this;
        },
        
<span id='jspyder-sp-query-method-filter'>        /** *******************************************************************
</span>         * Applies a single filter against the data stored in the cache.
         *
         * @param {Object} filterData
         *      A filter definition, with the following property set:
         *       - column: Required.  Name of the column being filtered.
         *       - geq:  &quot;Field value &gt;= this.geq&quot;       (3 &gt;= 3)
         *       - leq:  &quot;Field value &lt;= this.leq&quot;       (3 &lt;= 3)
         *       - gt:   &quot;Field value &gt; this.gt&quot;         (3 &gt; 2)
         *       - lt:   &quot;Field value &lt; this.lt&quot;         (3 &lt; 4)
         *       - eq:   &quot;Field value == this.eq&quot;        (3 == &quot;3&quot;)
         *       - seq:  &quot;Field value === this.seq&quot;      (3 === 3)
         *       - neq:  &quot;Field value != this.neq&quot;       (3 != 4)
         *       - snq:  &quot;Field value !== this.snq&quot;      (3 !== &quot;3&quot;)
         *       - test: &quot;Field value matches this.test&quot; (/^3/.test(3000))
         * *******************************************************************/
        filter: function(filterData) {
            if(filterData) {
                js.alg.arrEach(this._rows, __parseRows, { filterArray: [filterData], exclude: false });
            }
            return this;
        },
        
<span id='jspyder-sp-query-method-filters'>        /** *******************************************************************
</span>         * Applies a set of filters against the data stored in the cache. Due
         * to the nature of the filtering algorithm, this is the more efficient
         * of the two methods, as it requires fewer passes to apply multiple
         * filters.  (See: jspyder.sp.query.filter)
         *
         * @param {Array} filterArray
         *      Array of filter collections
         * *******************************************************************/
        filters: function(filterArray) {
            js.alg.arrEach(this._rows, __parseRows, { filterArray: filterArray, exclude: false });
            return this;
        },
        
        excludes: function(filterArray) {
            js.alg.arrEach(this._rows, __parseRows, { filterArray: filterArray, exclude: true });
            return this;
        },
        
        _cleanRows: function() {
            this._rows.sort();
            var index = this._rows.indexOf(null);
            if(index &gt; -1) {
                this._rows.splice(index);
            }
            return this;
        },
        
<span id='jspyder-sp-query-method-data'>        /** *******************************************************************
</span>         * Retrieves all stored data, and runs the function defined by [fn]
         * with the context [this] and the parameter pointing to a copy of the
         * data set.  Note that any changes to the array will mark the row for
         * change in the owning list.  
         *
         * @param {Function} fn
         *      Function to execute, with the context of the jspyder.sp.query
         *      object, and the first argument being the stored row references
         *      as an array.
         * *******************************************************************/
        data: function(fn) {
            js.alg.use(this, fn, [this._rows]);
            return this;
        },
        
<span id='jspyder-sp-query-method-sort'>        /**
</span>         * Sorts the rows in this query based on values, based on user-defined
         * criteria.
         * 
         * @param {String} field
         *      Field name to sort by
         * @param {Boolean} asc
         *      TRUE in order to sort ascending, FALSE in order to sort 
         *      descending.
         */
        sort: function (field, asc) {
            js.alg.sortArrayObj(this._rows, asc, field, &quot;value&quot;);
            return this;
        },
        
        each: function(fn) {
            js.alg.arrEach(this._rows, fn, this);
            return this;
        },
        
<span id='jspyder-sp-query-method-sum'>        /** *******************************************************************
</span>         * Retrieves the sum of all of the stored data, if it is numerical.
         * It not numerical, then makes no change to the default value 
         * provided.
         *
         * @param {Object} columns
         *      Object using column names (See: jspyder.sp.list) as the keys.
         *      Values are pushed into the object, and then [fn] is executed,
         *      with the context of the jspyder.sp.query object, and the 
         *      [columns] object as the first argument.
         * 
         * @param {Function} fn
         *      A callback function, using the jspyder.sp.query object as the
         *      context, and the columns object as the first argument.
         * *******************************************************************/
        sum: function(columns, fn) {
            this.data(function(rows) {
                // initialize default values...
                js.alg.each(columns, sp.query.fn._sum)
                    .alg.each(rows, sp.query.fn._sumRows, columns)
                    .alg.use(this, fn, [columns]);
            });
            
            return this;
        },
        
        _sum: function(column, key, columns) {
            columns[key] = column.value || column.default;
        },
                
        _sumRows: function (row, _, rows, columns) {
            js.alg.each(row, sp.query.fn._sumColumns, columns);
        },
        
        _sumColumns: function (value, colName, _, out) {
            switch(value.type) {
                case &quot;number&quot;:
                    out[colName] = js.alg.number(out[colName]) + js.alg.number(value.value);
                    break;
                    
                case &quot;string&quot;:
                case &quot;bitflag&quot;:
                default: 
                    out[colName] = value.value;
                    break;
            }
        },
        
<span id='jspyder-sp-query-method-getValues'>        /**
</span>         * Copies all of the values from the rows in the query into the object 
         * provided.
         */
        getValues: function (columns, fn) {
            // initializes [columns] variable
            js.alg.each(columns, function(v, k, columns) {
                columns[k] = {};
            });
            // iterates the rows
            this.each(function(row) {
                js.alg.each(columns, __copyColumn, row);
            });
            function __copyColumn(arr, key, columns, row) {
                arr[row[key].value] = true;
            }
            // sort the results
            js.alg.each(columns, function(obj, k, columns) {
                columns[k] = Object.keys(obj).sort();
            });
            
            js.alg.use(this, fn, [columns]);
            
            return this;
        },
        
<span id='jspyder-sp-query-method-clone'>        /** *******************************************************************
</span>         * Creates a copy of the jspyder.sp.query object; pointing to the same
         * jspyder.sp.list object, but with its own context of data copied from
         * the current cache.
         * 
         * @return {Object} jspyder.sp.query object clone.
         * *******************************************************************/
        clone: function() {
            var clone = sp.query(this._list);
            clone._rows = this._rows.slice(0);
            return clone;
        },
        
        toExcelString: function(name, columns) {
            return __generateXML(name, this._list, this._rows, columns);
        },
        
        toCsvString: function(columns) {
            return __generateCSV(this._list, this._rows, columns);
        }
    };

<span id='jspyder-sp-query-method-__parseRows'>    /** *******************************************************************
</span>     * @private
     * Separated from jspyder.sp.query.filter for memory efficiency.
     * 
     * @param {Object} value
     *      Row from this._rows
     * 
     * @param {Number} id
     *      Row index from row
     * 
     * @param {Array} _rows
     *      this._rows
     * 
     * @param {Object} filterData
     *      Collection of filters.  See jspyder.sp.query.filter
     * *******************************************************************/
    function __parseRows(row, id, _rows, data) {
        if(!row || !data || !data.filterArray || !data.filterArray.length) { // catch null values
            return;
        }
        
        var filterData = data.filterArray,
            exclude = data.exclude,
            f, filter, drop, value, orDrop;
        
        drop = false;
        
        for(f = 0; (!drop) &amp;&amp; (f &lt; filterData.length); f++) {
            filter = filterData[f];
            // make sure we have a column identified.
            if(!filter) { continue; } 
            if(!filter.column) { continue; }
            if(typeof row[filter.column] === &quot;undefined&quot;) { continue; }
            
            value = row[filter.column].value;
            orDrop = true;
            
            if(!drop &amp;&amp; (typeof filter.gt  !== &quot;undefined&quot;)) {
                if(filter.gt &amp;&amp; typeof filter.gt === &quot;object&quot;) {
                    js.alg.each(filter.gt, function(or) {
                        orDrop = orDrop &amp;&amp; !(value &gt; or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                }
                else { drop = !(value &gt; filter.gt ); } 
            } 
            if(!drop &amp;&amp; (typeof filter.geq !== &quot;undefined&quot;)) {
                if(filter.geq &amp;&amp; typeof filter.geq === &quot;object&quot;) {
                    js.alg.each(filter.geq, function(or) {
                        orDrop = orDrop &amp;&amp; !(value &gt;= or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value &gt;= filter.geq); } 
            } 
            if(!drop &amp;&amp; (typeof filter.leq !== &quot;undefined&quot;)) {
                if(filter.leq &amp;&amp; typeof filter.leq === &quot;object&quot;) {
                    js.alg.each(filter.leq, function(or) {
                        orDrop = orDrop &amp;&amp; !(value &lt;= or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value &lt;= filter.leq); } 
            } 
            if(!drop &amp;&amp; (typeof filter.lt  !== &quot;undefined&quot;)) {
                if(filter.lt &amp;&amp; typeof filter.lt === &quot;object&quot;) {
                    js.alg.each(filter.lt, function(or) {
                        orDrop = orDrop &amp;&amp; !(value &lt; or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value &lt; filter.lt ); } 
            }
            if(!drop &amp;&amp; (typeof filter.eq  !== &quot;undefined&quot;)) {
                if(filter.eq &amp;&amp; typeof filter.eq === &quot;object&quot;) {
                    js.alg.each(filter.eq, function(or) {
                        orDrop = orDrop &amp;&amp; !(value == or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value == filter.eq ); } 
            }
            if(!drop &amp;&amp; (typeof filter.seq !== &quot;undefined&quot;)) {
                if(filter.seq &amp;&amp; typeof filter.seq === &quot;object&quot;) {
                    js.alg.each(filter.seq, function(or) {
                        orDrop = orDrop &amp;&amp; !(value === or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value === filter.seq); } 
            }
            if(!drop &amp;&amp; (typeof filter.neq !== &quot;undefined&quot;)) {
                if(filter.neq &amp;&amp; typeof filter.neq === &quot;object&quot;) {
                    js.alg.each(filter.neq, function(or) {
                        orDrop = orDrop &amp;&amp; !(value != or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value != filter.neq); } 
            }
            if(!drop &amp;&amp; (typeof filter.snq !== &quot;undefined&quot;)) {
                if(filter.snq &amp;&amp; typeof filter.snq === &quot;object&quot;) {
                    js.alg.each(filter.snq, function(or) {
                        orDrop = orDrop &amp;&amp; !(value !== or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                } 
                else { drop = !(value !== filter.snq); } 
            }
            // binary
            if(!drop &amp;&amp; (typeof filter.and !== &quot;undefined&quot;)) {
                if(filter.and &amp;&amp; typeof filter.and === &quot;object&quot;) {
                    js.alg.each(filter.and, function(or) {
                        orDrop = orDrop &amp;&amp; !((value &amp; or) === or);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                }
                else { drop = !((value &amp; filter.and) === filter.and); }
            }
            if(!drop &amp;&amp; (typeof filter.not !== &quot;undefined&quot;)) {
                if(filter.not &amp;&amp; typeof filter.not === &quot;object&quot;) {
                    js.alg.each(filter.not, function(or) {
                        orDrop = orDrop &amp;&amp; !((value &amp; or) === 0);
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                }
                else { drop = !((value &amp; filter.not) === 0); }
            }
            
            if(!drop &amp;&amp; (typeof filter.test !== &quot;undefined&quot;)) { 
                // prevent invalid regexp values from breaking our query
                if(filter.test instanceof RegExp) { 
                    drop = !(filter.test.test(value));
                }
                else if(filter.test &amp;&amp; typeof filter.test === &quot;object&quot;) {
                    js.alg.each(filter.test, function(or) {
                        orDrop = orDrop &amp;&amp; !(or.test(value));
                        orDrop || this.stop();
                    });
                    drop = orDrop;
                }
            }
        }
        
        if((!exclude &amp;&amp; drop) || (exclude &amp;&amp; !drop)) {
            this.drop();
        }
        
        return this;
    }
    
    // used in sp list
<span id='jspyder-sp-column'>    /**
</span>     * @class jspyder.sp.column
     * @member jspyder.sp
     * 
     * Class definition
     */
    sp.column = function() {};
    sp.column.fn = {
<span id='jspyder-sp-column-property-internal'>        /**
</span>         * @property
         * @member jspyder.sp.column
         * 
         * String which identifies how SharePoint recognizes the column.
         */
        internal: &quot;&quot;,
<span id='jspyder-sp-column-property-text'>        /**
</span>         * @property
         * @member jspyder.sp.column
         * 
         * String which identifies how JSpyder should display the column name.
         */
        text: &quot;&quot;,
<span id='jspyder-sp-column-property-type'>        /**
</span>         * @property
         * @member jspyder.sp.column
         * 
         * String which identifies the type of column this corresponds to.
         */
        type: &quot;string&quot;,
<span id='jspyder-sp-column-property-default'>        /**
</span>         * @property {Mixed} default
         * @member jspyder.sp.column
         * 
         * Value which should be used in the absence of any other value.
         */
        default: &quot;&quot;,
<span id='jspyder-sp-column-property-value'>        /**
</span>         * @property {Mixed} [value]
         * @member jspyder.sp.column
         * 
         * Value which is stored in a particular cell.  This is only available
         * after queries have been performed.
         */
<span id='jspyder-sp-column-method-valueOf'>        /**
</span>         * @method
         * @member jspyder.sp.column
         * 
         * Retrieves the value stored in the cell, when columns are retrieved
         * during a query.
         */
        valueOf: function() { return this.value; }
    };
    
    function __generateXML (name, table, rows, columns, styles) {
        var xml = [
            &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot;,
            &quot;&lt;?mso-application progid=\&quot;Excel.Sheet\&quot;?&gt;&quot;,
            __workbook(name, rows, columns)];
            
        function __workbook(name, rows, columns) {
            return [
                &quot;&lt;ss:Workbook xmlns:ss=\&quot;urn:schemas-microsoft-com:office:spreadsheet\&quot;&gt;&quot;,
                    __styles(),
                    __worksheet(name, rows, columns),
                &quot;&lt;/ss:Workbook&gt;&quot;
            ].join(&#39;&#39;);
        }
        
        function __styles(styles) {
            return [
                &quot;&lt;ss:Styles&gt;&quot;,
                    &quot;&lt;ss:Style ss:ID=\&quot;1\&quot;&gt;&quot;,
                        &quot;&lt;ss:Font ss:Bold=\&quot;1\&quot; /&gt;&quot;,
                    &quot;&lt;/ss:Style&gt;&quot;,
                &quot;&lt;/ss:Styles&gt;&quot;
            ].join(&#39;&#39;);
        }
        
        function __worksheet(name, rows, columns) {
            return [
                &quot;&lt;ss:Worksheet ss:Name=\&quot;&quot;, name, &quot;\&quot;&gt;&quot;,
                    &quot;&lt;ss:Table&gt;&quot;,
                        __rows(rows, columns),
                    &quot;&lt;/ss:Table&gt;&quot;,
                &quot;&lt;/ss:Worksheet&gt;&quot;
            ].join(&#39;&#39;);
        }
        
        function __rows(rows, columns) {
            var __rows = [];
            
            __rows.push(&quot;&lt;ss:Row ss:StyleID=\&quot;1\&quot;&gt;&quot;);
            js.alg.arrEach(columns, __pushRow, &quot;text&quot;);
            __rows.push(&quot;&lt;/ss:Row&gt;&quot;);
            
            js.alg.arrEach(rows, function(row, i) {
                __rows.push(&quot;&lt;ss:Row&gt;&quot;);
                js.alg.arrEach(columns, __pushRow, &quot;value&quot;);
                __rows.push(&quot;&lt;/ss:Row&gt;&quot;);
            });
            
            function __pushRow (col, i, cols, data) {
                __rows.push([
                    &quot;&lt;ss:Cell&gt;&lt;ss:Data ss:Type=\&quot;String\&quot;&gt;&quot;, rows[col][data], &quot;&lt;/ss:Data&gt;&lt;/ss:Cell&gt;&quot;
                ].join(&#39;&#39;))
            }
            
            return __rows.join(&#39;&#39;);
        }
        
        return xml.join(&#39;&#39;);
    }
    
    function __generateCSV (table, rows, columns) {
        var csv = [
            &quot;\uFEFF&quot;,
            __headers(table, columns),
            &quot;\r\n&quot;,
            __rows(rows, columns)];
        
        function __headers(table, columns) {
            var __headers = [];
            js.alg.arrEach(columns, function(column) {
                __headers.push([&quot;\&quot;&quot;, table.getColumn(column).text || &quot; &quot;, &quot;\&quot;&quot;].join(&#39;&#39;));
            });
            return __headers.join(&#39;,&#39;);
        }
        
        function __rows(rows, columns) {
            var __rows = [],
                __oneRow = null;
            
            js.alg.arrEach(rows, function(row, i) {
                __oneRow = [];
                js.alg.arrEach(columns, __pushRow, { row: row, type: &quot;value&quot;, r: [] });
                __rows.push(__oneRow.join(&#39;,&#39;));
            });
            
            function __pushRow (col, i, cols, data) {
                data.row &amp;&amp; __oneRow.push([ &quot;\&quot;&quot;, (data.row[col] || {})[data.type] || &quot;&quot;, &quot;\&quot;&quot; ].join(&#39;&#39;));
            }
            
            return __rows.join(&#39;\r\n&#39;);
        }
        
        return csv.join(&#39;&#39;);
    }

    return sp;
});

//! js-sp.js</pre>
</body>
</html>
