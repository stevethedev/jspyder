<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* ****************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Steven Jimenez
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to 
 * deal in the Software without restriction, including without limitation the 
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
 * sell copies of the Software, and to permit persons to whom the Software is 
 * furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * ***************************************************************************/

jspyder.extend.fn(&quot;canvas&quot;, function () {
    var js = this;
    function js_canvas(settings) {
        settings = settings || {};
        var c = js.dom(&quot;&lt;canvas&gt;&lt;/canvas&gt;&quot;),
            attrs = {
                height: js.alg.number(settings.height, 150),
                width: js.alg.number(settings.width, 300)
            },
            css = settings.css,
            alt = settings.alt;

        c.setAttrs(attrs);
        c.setCss(css);
        c.setHtml(alt);

        return Object.create(js_canvas.fn, {
            canvas: { value: c },
            queue: { value: [] },
            context: { value: c._element[0] &amp;&amp; c._element[0].getContext &amp;&amp; c._element[0].getContext(&quot;2d&quot;) },
        });
    }

    js_canvas.fn = {
        canvas: null,
        context: null,
        queue: null,
        attach: function () {
            this.canvas &amp;&amp; this.canvas.attach(arguments);
            return this;
        },
        remove: function () {
            this.canvas &amp;&amp; this.canvas.remove();
            return this;
        },
        getSize: function (o, fn) {
            o = o || {};
            var element = this.canvas &amp;&amp; this.canvas._element &amp;&amp; this.canvas._element[0],
                rect;

            if (element) {
                rect = element.getBoundingClientRect();
                o.width = element.width;
                o.height = element.height;
                o.x = rect.x;
                o.y = rect.y;
                js.alg.use(this, fn, [o]);
            }
            return this;
        },
        clear: function () {
            var self = this;
            this.getSize({}, function (size) {
                self.context.clearRect(0, 0, size.width, size.height);
            });
            return this;
        },
        render: function () {
            this.clear();
            if (this.context) {
                var self = this;
                js.alg.each(this.queue, function (command) {
                    js.alg.use(self, command);
                });
            }
            return this;
        },
        draw: function (type, settings) {
            var cmd = this.cmd[type],
                data;

            if (cmd) {
                data = function () { js.alg.use(this, cmd, [settings]); };
                if (typeof data === &quot;function&quot;) {
                    data.settings = settings;
                    data.type = type;
                    this.queue &amp;&amp; this.queue.push(data);
                }
            }

            return this;
        },
        cmd: {
            rectangle: function (settings) {
                settings = __mergeSettings(settings);

                this.context.fillStyle = settings.border;
                this.context.fillRect(
                    settings.x,
                    settings.y,
                    settings.width,
                    settings.height);

                this.context.fillStyle = settings.fill;
                this.context.fillRect(
                    settings.x + settings.borderLeftWidth,
                    settings.y + settings.borderTopWidth,
                    settings.width - (settings.borderRightWidth + settings.borderLeftWidth),
                    settings.height - (settings.borderBottomWidth + settings.borderTopWidth));
            },
            arc: function (settings) {
                settings = __mergeSettings(settings);
                settings.radius = js.alg.number(settings.radius, 0);
                settings.anticlockwise = js.alg.bool(settings.anticlockwise, false);
                
                var angle = js.alg.deg2rad(settings.angle, 0),
                    degrees = js.alg.deg2rad(settings.degrees, 360) + angle;
                
                this.context.beginPath();
                
                this.context.arc(
                    settings.x,
                    settings.y,
                    settings.radius,
                    angle,
                    degrees,
                    settings.anticlockwise);
                    
                if (settings.fromcenter) {
                    this.context.lineTo(settings.x, settings.y);
                }
                if (settings.closepath) {
                    this.context.closePath();
                }
                
                this.context.strokeStyle = settings.border;
                this.context.stroke();
                
                this.context.fillStyle = settings.fill;
                this.context.fill();
            },
            pie: function (settings) {
                settings = __mergeSettings(settings);
                settings.radius = js.alg.number(settings.radius, 0);
                settings.angle = js.alg.number(settings.angle, -90);
                settings.anticlockwise = js.alg.bool(settings.anticlockwise, false);
                settings.closepath = true;
                
                var canvas = this,
                    total = 0,
                    angle = 0;
                    
                settings.degrees = 360;
                    
                js.alg.use(canvas, canvas.cmd.arc, [settings]);
                    
                js.alg.each(settings.sections, function (section) {
                    total += js.alg.number(section.value, 0);
                })
                js.alg.each(settings.sections, function (section) {
                    var deg = (js.alg.number(section.value, 0) / total) * 360,
                        arc = js.alg.mergeObj({}, settings, {
                            angle: angle + settings.angle,
                            degrees: deg,
                            fill: section.fill,
                            fromcenter: true,
                            closepath: true
                        });
                        angle += deg;
                        
                    js.alg.use(canvas, canvas.cmd.arc, [arc]);
                });
                return;
            },
            text: function (settings) {
                settings.size = js.alg.number(settings.size, 16);
                settings.font = js.alg.string(settings.font, &quot;Arial&quot;);
                settings.text = js.alg.string(settings.text, &quot;&quot;);
                settings.x = js.alg.string(settings.x, 0);
                settings.y = js.alg.string(settings.y, 0);
                settings.outline = js.alg.string(settings.outline, &quot;transparent&quot;);
                settings.fill = js.alg.string(settings.fill, &quot;black&quot;);
                
                this.context.font = settings.size + &quot;px &quot; + settings.font;
                this.context.fillStyle = settings.fill;
                this.context.fillText(settings.text, settings.x, settings.y);
                this.context.strokeStyle = settings.outline;
                this.context.strokeText(settings.text, settings.x, settings.y);
                
                return;
            }
        }
    };
    
    function __mergeSettings(settings) {
        settings = settings || {};
        
        settings.fill = js.alg.string(settings.fill, &quot;#FFF&quot;);
        settings.border = js.alg.string(settings.border, &quot;transparent&quot;);
        settings.borderWidth = js.alg.number(settings.borderWidth, 0);
        settings.borderTopWidth = js.alg.number(settings.borderTopWidth, settings.borderWidth);
        settings.borderRightWidth = js.alg.number(settings.borderRightWidth, settings.borderWidth);
        settings.borderBottomWidth = js.alg.number(settings.borderBottomWidth, settings.borderWidth);
        settings.borderLeftWidth = js.alg.number(settings.borderLeftWidth, settings.borderWidth);
        settings.x = js.alg.number(settings.x, 0);
        settings.y = js.alg.number(settings.y, 0);
        settings.height = js.alg.number(settings.height, 0);
        settings.width = js.alg.number(settings.width, 0);
        
        return settings;
    }
    
    return js_canvas;
});</pre>
</body>
</html>
